#include <stdio.h>
#include <stdlib.h>

#include "temperature.h"
#include "gpu.h"

#include "rk4_kernel_str.c"

/* default thermal configuration parameters	*/
gpu_config_t default_gpu_config(void)
{
	gpu_config_t config;
	
	config.gpu_enabled = 0;
	config.platform_id = 1;
	config.device_id = 1;
	
	/* rk4_cl is a string generated by rk4.cl */
	config._cl_kernel_string = rk4_cl;
	config._cl_kernel_size = rk4_cl_len;
	config._cl_kernel_rk4 = NULL;
	config._cl_context = NULL;
	config._cl_program = NULL;
	config._cl_queue = NULL;

	return config;
}

/* 
 * parse a table of name-value string pairs and add the configuration
 * parameters to 'config'
 */
void gpu_config_from_strs(gpu_config_t *config, str_pair *table, int size)
{
	int idx;
	if ((idx = get_str_index(table, size, "gpu_enable")) >= 0) {
		if(sscanf(table[idx].value, "%d", &config->gpu_enabled) != 1)
			fatal("invalid format for configuration parameter gpu_enable\n");
	}
	if ((idx = get_str_index(table, size, "gpu_platform")) >= 0) {
		if(sscanf(table[idx].value, "%d", &config->platform_id) != 1)
			fatal("invalid format for configuration parameter gpu_platform\n");
	}
	if ((idx = get_str_index(table, size, "gpu_device")) >= 0) {
		if(sscanf(table[idx].value, "%d", &config->device_id) != 1)
			fatal("invalid format for configuration parameter gpu_device\n");
	}
}

/* 
 * convert config into a table of name-value pairs. returns the no.
 * of parameters converted
 */
int gpu_config_to_strs(gpu_config_t *config, str_pair *table, int max_entries)
{
	if (max_entries < 3)
		fatal("not enough entries in table for gpu_config_to_strs()\n");

	sprintf(table[0].name, "gpu_enable");
	sprintf(table[1].name, "gpu_platform");
	sprintf(table[2].name, "gpu_device");

	sprintf(table[0].value, "%d", config->gpu_enabled);
	sprintf(table[1].value, "%d", config->platform_id);
	sprintf(table[2].value, "%d", config->device_id);

	return 3;
}

double gpu_rk4(void *model, double *y, void *p, int n, double *h, double *yout, slope_fn_ptr f)
{
	
}

void gpu_init(gpu_config_t *config)
{
	cl_platform_id platform;
	cl_device_id device;
	size_t value_size;
	char* device_name;
	int err;
	
	if (!config->gpu_enabled) {
		return;
	}
	
	printf("Initializing GPU device...\n");	

	// open platform	
	err = clGetPlatformIDs(config->platform_id, &platform, NULL);
	if(err < 0) {
		fatal("Couldn't open OpenCL platform");
	} 
	
	// open device
	err = clGetDeviceIDs(platform, CL_DEVICE_TYPE_GPU, config->device_id, &device, NULL);
	if(err == CL_DEVICE_NOT_FOUND) {
		err = clGetDeviceIDs(platform, CL_DEVICE_TYPE_CPU, config->device_id, &device, NULL);
		warning("No GPU devices found. Using CPU instead.");
	}
	if(err < 0) {
		fatal("Couldn't access any OpenCL devices"); 
	}

	// print device name
	clGetDeviceInfo(device, CL_DEVICE_NAME, 0, NULL, &value_size);
	device_name = (char*) malloc(value_size);
	clGetDeviceInfo(device, CL_DEVICE_NAME, value_size, device_name, NULL);
	printf("Selected OpenCL Platform %d Device %d: %s\n", config->platform_id, config->device_id, device_name);
	free(device_name);

	// Create OpenCL context
	config->_cl_context = clCreateContext(NULL, 1, &device, NULL, NULL, &err);
	if(err < 0) {
		fatal("Couldn't create an OpenCL context");  
	}

	// Create OpenCL program
	config->_cl_program = clCreateProgramWithSource(config->_cl_context, 1, (const char**)config->_cl_kernel_string, &config->_cl_kernel_size, &err);
	if(err < 0) {
		fatal("Couldn't create the OpenCL program");
	}
	
	// Build OpenCL program
	err = clBuildProgram(config->_cl_program, 0, NULL, NULL, NULL, NULL);
	if(err < 0) {
		char* build_log;
		// Build failure, print log 
		clGetProgramBuildInfo(config->_cl_program, device, CL_PROGRAM_BUILD_LOG, 0, NULL, &value_size);
		build_log = (char*) malloc(value_size + 1);
		build_log[value_size] = '\0';
		clGetProgramBuildInfo(config->_cl_program, device, CL_PROGRAM_BUILD_LOG, value_size + 1, build_log, NULL);
		printf("%s\n", build_log);
		free(build_log);
		fatal("Unabled to build the OpenCL program");
	}
	
	// Create a command queue
	config->_cl_queue = clCreateCommandQueue(config->_cl_context, device, 0, &err);
	if(err < 0) {
		fatal("Couldn't create an OpenCL command queue");
	};
	
	
}

void gpu_destory(gpu_config_t *config)
{
		
	if (!config->gpu_enabled) { 
		return;
	}
	
	// TODO
	// clReleaseKernel(config->_cl_kernel);
	// clReleaseMemObject(sum_buffer);
	// clReleaseMemObject(input_buffer);

	clReleaseCommandQueue(config->_cl_queue);
	clReleaseProgram(config->_cl_program);
	clReleaseContext(config->_cl_context);
	puts("OpenCL environment has been cleanup up.\n");
}


